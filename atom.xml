<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>榮彬的部落格</title>
  
  
  <link href="https://f10842287.github.io/atom.xml" rel="self"/>
  
  <link href="https://f10842287.github.io/"/>
  <updated>2025-06-15T18:41:28.215Z</updated>
  <id>https://f10842287.github.io/</id>
  
  <author>
    <name>鄧榮彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LLM &amp; RAG 練習</title>
    <link href="https://f10842287.github.io/2025/06/16/LLM-RAG-%E7%B7%B4%E7%BF%92/"/>
    <id>https://f10842287.github.io/2025/06/16/LLM-RAG-%E7%B7%B4%E7%BF%92/</id>
    <published>2025-06-15T18:37:07.000Z</published>
    <updated>2025-06-15T18:41:28.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-LLM-搭配-RAG-做練習"><a href="#使用-LLM-搭配-RAG-做練習" class="headerlink" title="使用 LLM 搭配 RAG 做練習"></a>使用 LLM 搭配 RAG 做練習</h1><h2 id="讀取-PDF-做簡單問答"><a href="#讀取-PDF-做簡單問答" class="headerlink" title="讀取 PDF 做簡單問答"></a>讀取 PDF 做簡單問答</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> PyPDFLoader</span><br><span class="line"><span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> FAISS</span><br><span class="line"><span class="keyword">from</span> langchain_huggingface <span class="keyword">import</span> HuggingFaceEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain_ollama <span class="keyword">import</span> OllamaLLM</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQA</span><br><span class="line"></span><br><span class="line">loader = PyPDFLoader(<span class="string">&quot;./pdf/test.pdf&quot;</span>)</span><br><span class="line">documents = loader.load()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">chunk_size 代表文字序列會以 chunk_size 為單位進行切割，chunk_overlap 代表每個 chunk 之間的重疊部分</span></span><br><span class="line"><span class="string">chunk1 = 第 1 到第 500 個字元， chunk2 = 第 451 到第 950 個字元，chunk 之間會有 50 個字元的重疊，確保文字的連貫性</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">splitter = CharacterTextSplitter(chunk_size=<span class="number">500</span>, chunk_overlap=<span class="number">50</span>)</span><br><span class="line">docs = splitter.split_documents(documents)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 HuggingFace 的 MiniLM 模型進行文本嵌入</span></span><br><span class="line">embedding_model = HuggingFaceEmbeddings(model_name=<span class="string">&quot;all-MiniLM-L6-v2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 FAISS 建立向量索引</span></span><br><span class="line">db = FAISS.from_documents(docs, embedding_model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 儲存向量索引到本地</span></span><br><span class="line">db.save_local(<span class="string">&quot;faiss_index&quot;</span>)</span><br><span class="line"></span><br><span class="line">llm = OllamaLLM(model=<span class="string">&quot;llama3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 RetrievalQA 進行問答系統的建立</span></span><br><span class="line">qa = RetrievalQA.from_chain_type(llm=llm, retriever=db.as_retriever())</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    query = <span class="built_in">input</span>(<span class="string">&quot;請輸入查詢問題: &quot;</span>)</span><br><span class="line">    response = qa.invoke(query)</span><br><span class="line">    <span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><h2 id="讀取圖片透過-OCR-技術轉成文字並使用-LLM-RAG-使用-RetrievalQA-，回傳-json"><a href="#讀取圖片透過-OCR-技術轉成文字並使用-LLM-RAG-使用-RetrievalQA-，回傳-json" class="headerlink" title="讀取圖片透過 OCR 技術轉成文字並使用 LLM &amp; RAG (使用 RetrievalQA)，回傳 json"></a>讀取圖片透過 OCR 技術轉成文字並使用 LLM &amp; RAG (使用 RetrievalQA)，回傳 json</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> FAISS</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> HuggingFaceEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQA</span><br><span class="line"><span class="keyword">from</span> langchain_ollama <span class="keyword">import</span> OllamaLLM</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. OCR 讀取圖片文字</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;./images/test.png&quot;</span>)</span><br><span class="line">text = pytesseract.image_to_string(image, lang=<span class="string">&#x27;eng&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用提示工程，定義一個提示樣板來格式化輸出為 JSON</span></span><br><span class="line">prompt_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你是一個專業的證件分析師，請根據內容提取證件中的資訊並以 JSON 格式輸出。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">內容:</span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義提示樣板</span></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;context&quot;</span>],</span><br><span class="line">    template=prompt_template</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文字切割</span></span><br><span class="line">splitter = CharacterTextSplitter(chunk_size=<span class="number">500</span>, chunk_overlap=<span class="number">50</span>)</span><br><span class="line">docs = splitter.split_text(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌入模型</span></span><br><span class="line">embedding_model = HuggingFaceEmbeddings(model_name=<span class="string">&quot;all-MiniLM-L6-v2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建向量資料庫</span></span><br><span class="line">db = FAISS.from_texts(docs, embedding_model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立檢索問答鏈</span></span><br><span class="line">llm = OllamaLLM(model=<span class="string">&quot;llama3&quot;</span>)</span><br><span class="line"></span><br><span class="line">qa = RetrievalQA.from_chain_type(</span><br><span class="line">    llm=llm,</span><br><span class="line">    chain_type=<span class="string">&quot;stuff&quot;</span>,</span><br><span class="line">    chain_type_kwargs=&#123;</span><br><span class="line">        <span class="string">&quot;prompt&quot;</span>: prompt</span><br><span class="line">    &#125;,</span><br><span class="line">    retriever=db.as_retriever()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 問答互動</span></span><br><span class="line">query = <span class="string">&quot;這是一個證件圖片，告訴我有什麼資訊。&quot;</span></span><br><span class="line">json_result = qa.invoke(query)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將結果寫入檔案</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json_result[<span class="string">&quot;result&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;結果已寫入 output.txt&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="還在研究中"><a href="#還在研究中" class="headerlink" title="還在研究中"></a>還在研究中</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-LLM-搭配-RAG-做練習&quot;&gt;&lt;a href=&quot;#使用-LLM-搭配-RAG-做練習&quot; class=&quot;headerlink&quot; title=&quot;使用 LLM 搭配 RAG 做練習&quot;&gt;&lt;/a&gt;使用 LLM 搭配 RAG 做練習&lt;/h1&gt;&lt;h2 id=&quot;讀取-PD</summary>
      
    
    
    
    <category term="Machine Learning" scheme="https://f10842287.github.io/categories/Machine-Learning/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 0386: Lexicographical Numbers</title>
    <link href="https://f10842287.github.io/2025/06/09/LeetCode-0386-Lexicographical-Numbers/"/>
    <id>https://f10842287.github.io/2025/06/09/LeetCode-0386-Lexicographical-Numbers/</id>
    <published>2025-06-08T16:50:12.000Z</published>
    <updated>2025-06-08T16:56:52.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>給予一整數 <code>n</code>，回傳所有範圍為 1 ~ n 的陣列<br>排序使用字典序排序，寫出來的演算法的時間複雜度、空間複雜度必須落在 O(n) 與 O(1)。</p></blockquote><blockquote><p><strong>Example 1:</strong><br>Input: n &#x3D; 13<br>Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]</p></blockquote><blockquote><p><strong>Example 2:</strong><br>Input: n &#x3D; 2<br>Output: [1,2]</p></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= n &lt;= 5 * 10^4</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ul><li>建立空陣列 result，將 1 ~ n 的數字放入 result</li><li>使用 sort()，搭配 lambda 函數判斷每一個數字轉換字串比大小，由小到大排序</li><li>sort() 的時間複雜度為 <code>O(n)</code></li></ul><p><strong>這邊是直接用函數去解，也有達到題目要求的限制，如果要用 DFS 解就要用 ASCII 表去對照大小，然後建 node，步驟比較多</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lexicalOrder</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建空陣列 result</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 從 1 到 n 的每個數字都加入 result</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            result.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 用 labmda 函數和 str() 對將數字轉成字串比較並排序</span></span><br><span class="line">        result.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;&lt;a href=&quot;#題目：&quot; class=&quot;headerlink&quot; title=&quot;題目：&quot;&gt;&lt;/a&gt;題目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;給予一整數 &lt;code&gt;n&lt;/code&gt;，回傳所有範圍為 1 ~ n 的陣列&lt;br&gt;排序使用字典序排序，寫</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://f10842287.github.io/categories/LeetCode/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 0027: Remove Element</title>
    <link href="https://f10842287.github.io/2025/06/04/LeetCode-0027-Remove-Element/"/>
    <id>https://f10842287.github.io/2025/06/04/LeetCode-0027-Remove-Element/</id>
    <published>2025-06-03T18:35:30.000Z</published>
    <updated>2025-06-03T18:37:32.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>給予一個整數陣列 <code>nums</code> 和一個 整數 <code>val</code><br>就地移除陣列裡 所有 <code>val</code>，陣列的順序可能會改變<br>回傳陣列中元素不等於 <code>val</code> 的數量</p></blockquote><blockquote><p>考慮元素中不為 <code>val</code> 的數量為 <code>k</code><br>為了被接受，需要以下條件</p></blockquote><blockquote><p>改變陣列 <code>nums</code>，使 <code>nums</code> 第一個 <code>k</code> 元素包含不等於 <code>val</code> 的元素<br><code>nums</code> 剩下的元素對於 <code>nums</code> 的數量並不重要。</p></blockquote><p>回傳 <code>k</code></p><blockquote><p>Example 1:<br>Input: nums &#x3D; [3,2,2,3], val &#x3D; 3<br>Output: 2, nums &#x3D; [2,2,<em>,</em>]</p></blockquote><blockquote><p>Example 2:<br>Input: nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>Output: 5, nums &#x3D; [0,1,4,0,3,<em>,</em>,_]</p></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li>0 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 50</li><li>0 &lt;&#x3D; val &lt;&#x3D; 100</li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><p>題目要求 <code>就地修改</code>, 所以給予一個新的陣列回傳答案是行不通的，一定要原本的陣列</p><p>第一種方法 時間複雜度 O(n^2):<br>直接用 while 判斷 <code>nums</code> 中是否有 <code>val</code><br>有的話用 array.remove() 移除</p><p>第二種方法 時間複雜度 O(n):<br>設置一個 counter 變數，並用 for 遍訪陣列，如果當前元素不等於 <code>val</code>，將 <code>nums[counter]</code> 賦予該值覆蓋掉元素</p><p>第三種方法 時間複雜度 O(n):<br>直接用 <code>list comprehension</code> 產生更改後的陣列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一種 O(n^2)</span></span><br><span class="line">        <span class="comment"># while val in nums:</span></span><br><span class="line">        <span class="comment">#     nums.remove(val)</span></span><br><span class="line">        <span class="comment"># return len(nums)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第三種 O(n)</span></span><br><span class="line">        <span class="comment"># nums[:] = [num for num in nums if num != val]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二種 O(n)</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[count] = nums[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;&lt;a href=&quot;#題目：&quot; class=&quot;headerlink&quot; title=&quot;題目：&quot;&gt;&lt;/a&gt;題目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;給予一個整數陣列 &lt;code&gt;nums&lt;/code&gt; 和一個 整數 &lt;code&gt;val&lt;/code&gt;&lt;br</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://f10842287.github.io/categories/LeetCode/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3024: Type of Triangle</title>
    <link href="https://f10842287.github.io/2025/06/03/LeetCode-3024-Type-of-Triangle/"/>
    <id>https://f10842287.github.io/2025/06/03/LeetCode-3024-Type-of-Triangle/</id>
    <published>2025-06-02T17:46:02.000Z</published>
    <updated>2025-06-02T17:51:01.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>給予一個整數陣列，長度為 3，每個元素為一個邊<br>陣列中 3 個邊可以組成三角形，以下為三角形種類:<br><code>當所有邊長度相同則為 正三角形</code><br><code>當兩個邊長度相同則為 等腰三角形</code><br><code>當所有邊長度不同則為 不等邊三角形</code><br>回傳一個字串，表示三角形是屬於哪一種類型</p></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>nums.length == 3</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ul><li>先把陣列由小到大排序，如果最小的兩個邊加起來沒辦法超過最大的代表沒辦法組成三角形</li><li>判斷正三角形、在判斷等腰、不等邊</li><li>如果三個邊沒辦法組成三角形輸出 None (條件: 兩邊和 &gt; 第三邊)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleType</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        這邊注意如果用 nums.sort() 的話沒辦法解包，因為 nums.sort() 會直接更改 array 內元素且不會返回值，因此沒辦法用解包賦值給 a, b, c</span></span><br><span class="line"><span class="string">        因此這邊用 sorted(nums) 做解包</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        a, b, c = <span class="built_in">sorted</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> a == b <span class="keyword">and</span> b == c:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;equilateral&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> a + b &gt; c:</span><br><span class="line">            <span class="keyword">if</span> a == b <span class="keyword">or</span> b == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;isosceles&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;scalene&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;&lt;a href=&quot;#題目：&quot; class=&quot;headerlink&quot; title=&quot;題目：&quot;&gt;&lt;/a&gt;題目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;給予一個整數陣列，長度為 3，每個元素為一個邊&lt;br&gt;陣列中 3 個邊可以組成三角形，以下為三角形種類:&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://f10842287.github.io/categories/LeetCode/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 0020: Valid Parentheses</title>
    <link href="https://f10842287.github.io/2025/06/01/LeetCode-0020-Valid-Parentheses/"/>
    <id>https://f10842287.github.io/2025/06/01/LeetCode-0020-Valid-Parentheses/</id>
    <published>2025-05-31T16:35:17.000Z</published>
    <updated>2025-05-31T16:35:56.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>給予字串 s<br>s 只包含 <code>(</code>、<code>)</code>、<code>&#123;</code>、<code>&#125;</code>、<code>[</code>、<code>]</code> 符號<br>判斷 s 字串是否為合法的</p></blockquote><p>合法條件</p><blockquote><ol><li>左括號必須和相同類型的括號閉合</li><li>左括號必須照正確的順序閉合</li><li>每一個右括號會有一個對應相同類型的左括號</li></ol></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s 只包含 ()[]&#123;&#125; 三種模式</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ul><li>宣告一個空陣列 stack ，放每一個字元</li><li>針對 s 字串遍訪，每個字元跟 stack 最後面元素比對，如果匹配就把 stack 匹配的元素清除</li><li>如果 stack 陣列還有剩回傳 false，相反 true</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        mapping = &#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 代表遇到右括號</span></span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> mapping:</span><br><span class="line">                <span class="comment"># 如果堆疊是空的，或是堆疊最頂層不是匹配的左括號就回傳 false</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != mapping[char]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 如果有匹配到左括號，將堆疊最上方清除</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果是左括號，就加入堆疊</span></span><br><span class="line">                stack.append(char)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;&lt;a href=&quot;#題目：&quot; class=&quot;headerlink&quot; title=&quot;題目：&quot;&gt;&lt;/a&gt;題目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;給予字串 s&lt;br&gt;s 只包含 &lt;code&gt;(&lt;/code&gt;、&lt;code&gt;)&lt;/code&gt;、&lt;code&gt;&amp;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://f10842287.github.io/categories/LeetCode/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2359: Find Closest Node to Given Two Nodes</title>
    <link href="https://f10842287.github.io/2025/05/31/LeetCode-2359-Find-Closest-Node-to-Given-Two-Nodes/"/>
    <id>https://f10842287.github.io/2025/05/31/LeetCode-2359-Find-Closest-Node-to-Given-Two-Nodes/</id>
    <published>2025-05-30T17:54:55.000Z</published>
    <updated>2025-05-30T18:22:06.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><p>給予一含有 n 個 node 的 graph (從 0 ~ n - 1)<br>每一個 node 最多有一個指出去的路徑</p><p>graph 由 索引 0 開始，長度為 n<br>edges[i] 代表 node <code>i</code> 指向的路徑<br>edges[i] &#x3D;&#x3D; -1 代表沒有可以指出去的路徑</p><p>給予 node1、node2<br>分別從 node1、node2 出發走 graph</p><p>找出 node1、node2 共通的 node 並回傳最大的距離，如果有多個答案， 回傳最小索引的 node<br>如果沒有任何答案，回傳 -1</p><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>n == edges.length</code></li><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>-1 &lt;= edges[i] &lt; n</code></li><li><code>edges[i] != i</code></li><li><code>0 &lt;= node1, node2 &lt; n</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><p>用 DFS 解，找離兩個路徑最近的節點，如果最近的節點有多個情況下，回傳最小索引的節點</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closestMeetingNode</span>(<span class="params">self, edges, node1, node2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type edges: List[int]</span></span><br><span class="line"><span class="string">        :type node1: int</span></span><br><span class="line"><span class="string">        :type node2: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        distances_from_node1 = &#123;&#125;</span><br><span class="line">        distances_from_node2 = &#123;&#125;</span><br><span class="line">        visited_from_node1 = <span class="built_in">set</span>()</span><br><span class="line">        visited_from_node2 = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, visited, distances</span>):</span><br><span class="line">            <span class="keyword">if</span> node == -<span class="number">1</span> <span class="keyword">or</span> node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited.add(node)</span><br><span class="line">                distances[node] = <span class="built_in">len</span>(visited) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> edges[node] == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> distances[node] + dfs(edges[node], visited, distances)</span><br><span class="line">        </span><br><span class="line">        dfs(node1, visited_from_node1, distances_from_node1)</span><br><span class="line">        dfs(node2, visited_from_node2, distances_from_node2)</span><br><span class="line">        </span><br><span class="line">        closest_node = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        smallest_max_distance = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(distances_from_node1, distances_from_node2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> distances_from_node1:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> distances_from_node2:</span><br><span class="line">                <span class="comment"># 計算兩個距離的最大值</span></span><br><span class="line">                max_distance = <span class="built_in">max</span>(distances_from_node1[node], distances_from_node2[node])</span><br><span class="line">                <span class="comment"># 更新最小的最大距離和對應的節點</span></span><br><span class="line">                <span class="keyword">if</span> max_distance &lt; smallest_max_distance <span class="keyword">or</span> (max_distance == smallest_max_distance <span class="keyword">and</span> node &lt; closest_node):</span><br><span class="line">                    smallest_max_distance = max_distance</span><br><span class="line">                    closest_node = node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> closest_node <span class="keyword">if</span> closest_node != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;&lt;a href=&quot;#題目：&quot; class=&quot;headerlink&quot; title=&quot;題目：&quot;&gt;&lt;/a&gt;題目：&lt;/h2&gt;&lt;p&gt;給予一含有 n 個 node 的 graph (從 0 ~ n - 1)&lt;br&gt;每一個 node 最多有一個指出去的路徑&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://f10842287.github.io/categories/LeetCode/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2984: Divisible and Non divisible Sums Difference</title>
    <link href="https://f10842287.github.io/2025/05/29/LeetCode-2984-Divisible-and-Non-divisible-Sums-Difference/"/>
    <id>https://f10842287.github.io/2025/05/29/LeetCode-2984-Divisible-and-Non-divisible-Sums-Difference/</id>
    <published>2025-05-28T16:51:11.000Z</published>
    <updated>2025-05-30T18:22:11.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>給一正整數 n 和 m<br>定義以下兩個整數<br>num1: 在 1 ~ n 之間不可被 m 整除的所有整數和<br>num2: 在 1 ~ n 之間可被 m 整除的所有整數和<br>回傳 num1 - num2</p></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= n, m &lt;= 1000</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ul><li>直接使用 <code>python comprehension</code> 生成 1 ~ n 之間的整數和，並判斷是否<code>不可被 m 整除</code></li><li>直接使用 <code>python comprehension</code> 生成 1 ~ n 之間的整數和，並判斷是否<code>可被 m 整除</code></li><li>回傳 result</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">differenceOfSums</span>(<span class="params">self, n, m</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num1 = <span class="built_in">sum</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>) <span class="keyword">if</span> x % m != <span class="number">0</span>])</span><br><span class="line">        num2 = <span class="built_in">sum</span>([y <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>) <span class="keyword">if</span> y % m == <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> num1 - num2</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;&lt;a href=&quot;#題目：&quot; class=&quot;headerlink&quot; title=&quot;題目：&quot;&gt;&lt;/a&gt;題目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;給一正整數 n 和 m&lt;br&gt;定義以下兩個整數&lt;br&gt;num1: 在 1 ~ n 之間不可被 m 整除的所</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://f10842287.github.io/categories/LeetCode/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 0014: Longest Common Prefix</title>
    <link href="https://f10842287.github.io/2025/05/27/LeetCode-0014-Longest-Common-Prefix/"/>
    <id>https://f10842287.github.io/2025/05/27/LeetCode-0014-Longest-Common-Prefix/</id>
    <published>2025-05-26T17:29:55.000Z</published>
    <updated>2025-05-30T18:22:01.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>撰寫一個函數，找出字串陣列中最長的通用 prefix 字串<br>如果沒有任何通用 prefix 字串，則回傳 “”</p></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i] 如果不為空，則 strs[i] 只會是小寫字母</code></li></ul><h2 id="輸入輸出"><a href="#輸入輸出" class="headerlink" title="輸入輸出"></a>輸入輸出</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><blockquote><p>Input: strs &#x3D; [“flower”,”flow”,”flight”]<br>Output: “fl”</p></blockquote><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><blockquote><p>Input: strs &#x3D; [“dog”,”racecar”,”car”]<br>Output: “”<br>Explanation: There is no common prefix among the input strings.</p></blockquote><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ol><li>準備一個字典陣列 result 和最小字串 min_str</li><li>遍訪 strs 陣列，將 strs[i] 跟 min_str 做字元比對，利用 counter 變數紀錄最長 prefix，將結果放入 result</li><li>檢查 result 是否為空，如果是空代表裡面是空字串直接回傳 min_str，否則回傳 result 中每個 str 中最短的前輟</li></ol><p><strong>這題的時間複雜度用到了 O(n ^ m)，外層迴圈 n 次，內部迴圈 m 次 (看最小字串多長)，在想一下怎麼改善</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        min_str = <span class="built_in">min</span>(strs, key=<span class="built_in">len</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">            <span class="comment"># 不判斷自己本身</span></span><br><span class="line">            <span class="keyword">if</span> strs[i] == min_str:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 設定 counter 變數，計算最小字串與當前字串的相同前綴長度</span></span><br><span class="line">                counter = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 比較當前字串與最小字串的每個字符</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(min_str)):</span><br><span class="line">                    <span class="keyword">if</span> strs[i][j] != min_str[j]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        counter += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 將當前字串的相同前綴長度存入結果</span></span><br><span class="line">                result[strs[i]] = min_str[:counter]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果 result 為空，代表 strs 中為空字串，則返回最小字串，否則則回傳 result 中最短前輟</span></span><br><span class="line">        <span class="keyword">return</span> min_str <span class="keyword">if</span> <span class="keyword">not</span> result <span class="keyword">else</span> <span class="built_in">min</span>(result.values(), key=<span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;&lt;a href=&quot;#題目：&quot; class=&quot;headerlink&quot; title=&quot;題目：&quot;&gt;&lt;/a&gt;題目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;撰寫一個函數，找出字串陣列中最長的通用 prefix 字串&lt;br&gt;如果沒有任何通用 prefix 字串，則</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://f10842287.github.io/categories/LeetCode/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2900: Longest Unequal Adjacent Groups Subsequence I</title>
    <link href="https://f10842287.github.io/2025/05/26/LeetCode-2900-Longest-Unequal-Adjacent-Groups-Subsequence-I/"/>
    <id>https://f10842287.github.io/2025/05/26/LeetCode-2900-Longest-Unequal-Adjacent-Groups-Subsequence-I/</id>
    <published>2025-05-26T07:47:32.000Z</published>
    <updated>2025-05-30T18:22:07.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><p>有一字串陣列 words 和 二元陣列 groups，兩個長度皆為 length n<br>words 的子序列是交錯的，當任何兩個連續的字串在序列中，且相對應的元素在 groups 是不同的索引時<br>則為子序列</p><p>題目的要求為從 words 找出最長交錯的子陣列<br>回傳 子陣列，如果有複數答案則回傳任何一個。</p><p>words 的每個元素是獨立的</p><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= n == words.length == groups.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>groups[i] is 0 or 1</code></li><li><code>words[i] is lowercase letter</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ol><li>建一個空陣列 result</li><li>把 words[0] 放進 result 陣列</li><li>遍訪 group 陣列，索引從 1 ~ range(len(groups))</li><li>當 groups[i] !&#x3D; groups[i - 1]，就放進去 result 陣列</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLongestSubsequence</span>(<span class="params">self, words, groups</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type groups: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        result = [words[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(groups)):</span><br><span class="line">            <span class="keyword">if</span> groups[i] != groups[i - <span class="number">1</span>]:</span><br><span class="line">                result.append(words[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;&lt;a href=&quot;#題目：&quot; class=&quot;headerlink&quot; title=&quot;題目：&quot;&gt;&lt;/a&gt;題目：&lt;/h2&gt;&lt;p&gt;有一字串陣列 words 和 二元陣列 groups，兩個長度皆為 length n&lt;br&gt;words 的子序列是交錯的，當任何兩個</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://f10842287.github.io/categories/LeetCode/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2942: Find Words Containing Character</title>
    <link href="https://f10842287.github.io/2025/05/26/LeetCode-2942-Find-Words-Containing-Character/"/>
    <id>https://f10842287.github.io/2025/05/26/LeetCode-2942-Find-Words-Containing-Character/</id>
    <published>2025-05-26T07:10:40.000Z</published>
    <updated>2025-05-30T18:22:09.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><p>給予一字串陣列 “words” 和一個字元 x<br>回傳符合的所有索引(以陣列表示) -&gt; 索引為 word 裡含有 ‘x’ 的字元的 key<br>(回傳的陣列有可能不照順序)</p><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= words.length &lt;= 50</code></li><li><code>1 &lt;= words[i].length &lt;= 50</code></li><li><code>x is lowercase</code></li><li><code>words[i] 只包含 lowercase letter</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ul><li>準備一個空陣列，從 words 字串陣列遍訪，如果有符合 <code>x</code> 字元，就將目前陣列的 <code>索引</code>  值放入空陣列</li><li>Python 可以直接用 <code>list comprehension</code> 生成陣列，條件判斷用 <code>[i for key, value in enumerate(words) if x in value]</code></li><li><code>enumerate</code> 對可迭代的物件進行遍訪，使用 <code>enumerate</code> 函數可以同時取得 <code>key</code> 和 <code>value</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findWordsContaining</span>(<span class="params">self, words, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type x: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># check words length is between 1 and 50</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(words) &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(words) &gt; <span class="number">50</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="comment"># check each word length is between 1 and 100</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(word) &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(word) &gt; <span class="number">50</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> word.islower() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="comment"># check x is lowercase letter</span></span><br><span class="line">        <span class="keyword">if</span> x.islower():</span><br><span class="line">            <span class="keyword">return</span> [i <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words) <span class="keyword">if</span> x <span class="keyword">in</span> word]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;&lt;a href=&quot;#題目：&quot; class=&quot;headerlink&quot; title=&quot;題目：&quot;&gt;&lt;/a&gt;題目：&lt;/h2&gt;&lt;p&gt;給予一字串陣列 “words” 和一個字元 x&lt;br&gt;回傳符合的所有索引(以陣列表示) -&amp;gt; 索引為 word 裡含有 ‘x’</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://f10842287.github.io/categories/LeetCode/"/>
    
    
    <category term="Python" scheme="https://f10842287.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>hexo 基本設定</title>
    <link href="https://f10842287.github.io/2025/05/26/hexo-%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A/"/>
    <id>https://f10842287.github.io/2025/05/26/hexo-%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A/</id>
    <published>2025-05-26T06:06:17.000Z</published>
    <updated>2025-05-26T09:07:32.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-基本設定"><a href="#Hexo-基本設定" class="headerlink" title="Hexo 基本設定"></a>Hexo 基本設定</h1><h2 id="初始化專案"><a href="#初始化專案" class="headerlink" title="初始化專案"></a>初始化專案</h2><pre><code>hexo init [folder name]</code></pre><p>範例</p><pre><code>hexo init my-blog</code></pre><h2 id="建立新文章"><a href="#建立新文章" class="headerlink" title="建立新文章"></a>建立新文章</h2><pre><code>hexo new [layout] &lt;標題&gt;</code></pre><p>範例</p><pre><code>hexo new post &quot;第一篇文章&quot;</code></pre><h2 id="local-端啟動伺服器"><a href="#local-端啟動伺服器" class="headerlink" title="local 端啟動伺服器"></a>local 端啟動伺服器</h2><pre><code>hexo server # 預設為 http://localhost:4000/</code></pre><h2 id="調整文章內容"><a href="#調整文章內容" class="headerlink" title="調整文章內容"></a>調整文章內容</h2><p>當執行完以下指令後:</p><pre><code>hexo new post &quot;第一篇文章&quot;</code></pre><p>會在 <code>source/_posts/</code> 底下產生 .md 檔案，<code>source/_posts/第一篇文章.md</code><br>.md 檔案內容如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---  </span><br><span class="line">title: 我的第一篇文章 By Hexo  </span><br><span class="line">date: 2021-03-07 17:15:57  </span><br><span class="line"><span class="section">tags:  </span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 文章標題</span></span><br><span class="line">內容自訂</span><br></pre></td></tr></table></figure><p>上面 <code>---</code> 包住的區域為 front-matter，用來敘述文章屬性，詳細參考 <a href="https://hexo.io/zh-tw/docs/front-matter">front-matter</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-基本設定&quot;&gt;&lt;a href=&quot;#Hexo-基本設定&quot; class=&quot;headerlink&quot; title=&quot;Hexo 基本設定&quot;&gt;&lt;/a&gt;Hexo 基本設定&lt;/h1&gt;&lt;h2 id=&quot;初始化專案&quot;&gt;&lt;a href=&quot;#初始化專案&quot; class=&quot;header</summary>
      
    
    
    
    <category term="教學" scheme="https://f10842287.github.io/categories/%E6%95%99%E5%AD%B8/"/>
    
    
    <category term="hexo" scheme="https://f10842287.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
