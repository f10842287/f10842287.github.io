<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 0386: Lexicographical Numbers</title>
      <link href="/2025/06/09/LeetCode-0386-Lexicographical-Numbers/"/>
      <url>/2025/06/09/LeetCode-0386-Lexicographical-Numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><p>給予一整數 <code>n</code>，回傳所有範圍為 1 ~ n 的陣列<br>排序使用字典序排序，寫出來的演算法的時間複雜度、空間複雜度必須落在 O(n) 與 O(1)。</p><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li>1 &lt;&#x3D; n &lt;&#x3D; 5 * 10^4</li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ol><li>建立空陣列 result，將 1 ~ n 的數字放入 result</li><li>使用 sort()，搭配 lambda 函數判斷每一個數字轉換字串比大小，由小到大</li><li>sort() 的時間複雜度為 O(n)</li></ol><p>** 這邊是直接用函數去解，也有達到題目要求的限制，如果要用 DFS 解就要用 ASCII 表去對照大小，然後建 node，步驟比較多 **</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lexicalOrder</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建空陣列 result</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 從 1 到 n 的每個數字都加入 result</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            result.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 用 labmda 函數和 str() 對將數字轉成字串比較並排序</span></span><br><span class="line">        result.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 0027: Remove Element</title>
      <link href="/2025/06/04/LeetCode-0027-Remove-Element/"/>
      <url>/2025/06/04/LeetCode-0027-Remove-Element/</url>
      
        <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>給予一個整數陣列 <code>nums</code> 和一個 整數 <code>val</code><br>就地移除陣列裡 所有 <code>val</code>，陣列的順序可能會改變<br>回傳陣列中元素不等於 <code>val</code> 的數量</p></blockquote><blockquote><p>考慮元素中不為 <code>val</code> 的數量為 <code>k</code><br>為了被接受，需要以下條件</p></blockquote><blockquote><p>改變陣列 <code>nums</code>，使 <code>nums</code> 第一個 <code>k</code> 元素包含不等於 <code>val</code> 的元素<br><code>nums</code> 剩下的元素對於 <code>nums</code> 的數量並不重要。</p></blockquote><p>回傳 <code>k</code></p><blockquote><p>Example 1:<br>Input: nums &#x3D; [3,2,2,3], val &#x3D; 3<br>Output: 2, nums &#x3D; [2,2,<em>,</em>]</p></blockquote><blockquote><p>Example 2:<br>Input: nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>Output: 5, nums &#x3D; [0,1,4,0,3,<em>,</em>,_]</p></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li>0 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 50</li><li>0 &lt;&#x3D; val &lt;&#x3D; 100</li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><p>題目要求 <code>就地修改</code>, 所以給予一個新的陣列回傳答案是行不通的，一定要原本的陣列</p><p>第一種方法 時間複雜度 O(n^2):<br>直接用 while 判斷 <code>nums</code> 中是否有 <code>val</code><br>有的話用 array.remove() 移除</p><p>第二種方法 時間複雜度 O(n):<br>設置一個 counter 變數，並用 for 遍訪陣列，如果當前元素不等於 <code>val</code>，將 <code>nums[counter]</code> 賦予該值覆蓋掉元素</p><p>第三種方法 時間複雜度 O(n):<br>直接用 <code>list comprehension</code> 產生更改後的陣列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一種 O(n^2)</span></span><br><span class="line">        <span class="comment"># while val in nums:</span></span><br><span class="line">        <span class="comment">#     nums.remove(val)</span></span><br><span class="line">        <span class="comment"># return len(nums)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第三種 O(n)</span></span><br><span class="line">        <span class="comment"># nums[:] = [num for num in nums if num != val]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二種 O(n)</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[count] = nums[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 3024: Type of Triangle</title>
      <link href="/2025/06/03/LeetCode-3024-Type-of-Triangle/"/>
      <url>/2025/06/03/LeetCode-3024-Type-of-Triangle/</url>
      
        <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>給予一個整數陣列，長度為 3，每個元素為一個邊<br>陣列中 3 個邊可以組成三角形，以下為三角形種類:<br><code>當所有邊長度相同則為 正三角形</code><br><code>當兩個邊長度相同則為 等腰三角形</code><br><code>當所有邊長度不同則為 不等邊三角形</code><br>回傳一個字串，表示三角形是屬於哪一種類型</p></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>nums.length == 3</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ul><li>先把陣列由小到大排序，如果最小的兩個邊加起來沒辦法超過最大的代表沒辦法組成三角形</li><li>判斷正三角形、在判斷等腰、不等邊</li><li>如果三個邊沒辦法組成三角形輸出 None (條件: 兩邊和 &gt; 第三邊)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triangleType</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        這邊注意如果用 nums.sort() 的話沒辦法解包，因為 nums.sort() 會直接更改 array 內元素且不會返回值，因此沒辦法用解包賦值給 a, b, c</span></span><br><span class="line"><span class="string">        因此這邊用 sorted(nums) 做解包</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        a, b, c = <span class="built_in">sorted</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> a == b <span class="keyword">and</span> b == c:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;equilateral&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> a + b &gt; c:</span><br><span class="line">            <span class="keyword">if</span> a == b <span class="keyword">or</span> b == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;isosceles&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;scalene&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 0020: Valid Parentheses</title>
      <link href="/2025/06/01/LeetCode-0020-Valid-Parentheses/"/>
      <url>/2025/06/01/LeetCode-0020-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>給予字串 s<br>s 只包含 <code>(</code>、<code>)</code>、<code>&#123;</code>、<code>&#125;</code>、<code>[</code>、<code>]</code> 符號<br>判斷 s 字串是否為合法的</p></blockquote><p>合法條件</p><blockquote><ol><li>左括號必須和相同類型的括號閉合</li><li>左括號必須照正確的順序閉合</li><li>每一個右括號會有一個對應相同類型的左括號</li></ol></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s 只包含 ()[]&#123;&#125; 三種模式</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ul><li>宣告一個空陣列 stack ，放每一個字元</li><li>針對 s 字串遍訪，每個字元跟 stack 最後面元素比對，如果匹配就把 stack 匹配的元素清除</li><li>如果 stack 陣列還有剩回傳 false，相反 true</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        mapping = &#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 代表遇到右括號</span></span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> mapping:</span><br><span class="line">                <span class="comment"># 如果堆疊是空的，或是堆疊最頂層不是匹配的左括號就回傳 false</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != mapping[char]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 如果有匹配到左括號，將堆疊最上方清除</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果是左括號，就加入堆疊</span></span><br><span class="line">                stack.append(char)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 2359: Find Closest Node to Given Two Nodes</title>
      <link href="/2025/05/31/LeetCode-2359-Find-Closest-Node-to-Given-Two-Nodes/"/>
      <url>/2025/05/31/LeetCode-2359-Find-Closest-Node-to-Given-Two-Nodes/</url>
      
        <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><p>給予一含有 n 個 node 的 graph (從 0 ~ n - 1)<br>每一個 node 最多有一個指出去的路徑</p><p>graph 由 索引 0 開始，長度為 n<br>edges[i] 代表 node <code>i</code> 指向的路徑<br>edges[i] &#x3D;&#x3D; -1 代表沒有可以指出去的路徑</p><p>給予 node1、node2<br>分別從 node1、node2 出發走 graph</p><p>找出 node1、node2 共通的 node 並回傳最大的距離，如果有多個答案， 回傳最小索引的 node<br>如果沒有任何答案，回傳 -1</p><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>n == edges.length</code></li><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>-1 &lt;= edges[i] &lt; n</code></li><li><code>edges[i] != i</code></li><li><code>0 &lt;= node1, node2 &lt; n</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><p>用 DFS 解，找離兩個路徑最近的節點，如果最近的節點有多個情況下，回傳最小索引的節點</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closestMeetingNode</span>(<span class="params">self, edges, node1, node2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type edges: List[int]</span></span><br><span class="line"><span class="string">        :type node1: int</span></span><br><span class="line"><span class="string">        :type node2: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        distances_from_node1 = &#123;&#125;</span><br><span class="line">        distances_from_node2 = &#123;&#125;</span><br><span class="line">        visited_from_node1 = <span class="built_in">set</span>()</span><br><span class="line">        visited_from_node2 = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, visited, distances</span>):</span><br><span class="line">            <span class="keyword">if</span> node == -<span class="number">1</span> <span class="keyword">or</span> node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited.add(node)</span><br><span class="line">                distances[node] = <span class="built_in">len</span>(visited) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> edges[node] == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> distances[node] + dfs(edges[node], visited, distances)</span><br><span class="line">        </span><br><span class="line">        dfs(node1, visited_from_node1, distances_from_node1)</span><br><span class="line">        dfs(node2, visited_from_node2, distances_from_node2)</span><br><span class="line">        </span><br><span class="line">        closest_node = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        smallest_max_distance = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(distances_from_node1, distances_from_node2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> distances_from_node1:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> distances_from_node2:</span><br><span class="line">                <span class="comment"># 計算兩個距離的最大值</span></span><br><span class="line">                max_distance = <span class="built_in">max</span>(distances_from_node1[node], distances_from_node2[node])</span><br><span class="line">                <span class="comment"># 更新最小的最大距離和對應的節點</span></span><br><span class="line">                <span class="keyword">if</span> max_distance &lt; smallest_max_distance <span class="keyword">or</span> (max_distance == smallest_max_distance <span class="keyword">and</span> node &lt; closest_node):</span><br><span class="line">                    smallest_max_distance = max_distance</span><br><span class="line">                    closest_node = node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> closest_node <span class="keyword">if</span> closest_node != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 2984: Divisible and Non divisible Sums Difference</title>
      <link href="/2025/05/29/LeetCode-2984-Divisible-and-Non-divisible-Sums-Difference/"/>
      <url>/2025/05/29/LeetCode-2984-Divisible-and-Non-divisible-Sums-Difference/</url>
      
        <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>給一正整數 n 和 m<br>定義以下兩個整數<br>num1: 在 1 ~ n 之間不可被 m 整除的所有整數和<br>num2: 在 1 ~ n 之間可被 m 整除的所有整數和<br>回傳 num1 - num2</p></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= n, m &lt;= 1000</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ul><li>直接使用 <code>python comprehension</code> 生成 1 ~ n 之間的整數和，並判斷是否<code>不可被 m 整除</code></li><li>直接使用 <code>python comprehension</code> 生成 1 ~ n 之間的整數和，並判斷是否<code>可被 m 整除</code></li><li>回傳 result</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">differenceOfSums</span>(<span class="params">self, n, m</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num1 = <span class="built_in">sum</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>) <span class="keyword">if</span> x % m != <span class="number">0</span>])</span><br><span class="line">        num2 = <span class="built_in">sum</span>([y <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>) <span class="keyword">if</span> y % m == <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> num1 - num2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 0014: Longest Common Prefix</title>
      <link href="/2025/05/27/LeetCode-0014-Longest-Common-Prefix/"/>
      <url>/2025/05/27/LeetCode-0014-Longest-Common-Prefix/</url>
      
        <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><blockquote><p>撰寫一個函數，找出字串陣列中最長的通用 prefix 字串<br>如果沒有任何通用 prefix 字串，則回傳 “”</p></blockquote><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i] 如果不為空，則 strs[i] 只會是小寫字母</code></li></ul><h2 id="輸入輸出"><a href="#輸入輸出" class="headerlink" title="輸入輸出"></a>輸入輸出</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><blockquote><p>Input: strs &#x3D; [“flower”,”flow”,”flight”]<br>Output: “fl”</p></blockquote><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><blockquote><p>Input: strs &#x3D; [“dog”,”racecar”,”car”]<br>Output: “”<br>Explanation: There is no common prefix among the input strings.</p></blockquote><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ol><li>準備一個字典陣列 result 和最小字串 min_str</li><li>遍訪 strs 陣列，將 strs[i] 跟 min_str 做字元比對，利用 counter 變數紀錄最長 prefix，將結果放入 result</li><li>檢查 result 是否為空，如果是空代表裡面是空字串直接回傳 min_str，否則回傳 result 中每個 str 中最短的前輟</li></ol><p><strong>這題的時間複雜度用到了 O(n ^ m)，外層迴圈 n 次，內部迴圈 m 次 (看最小字串多長)，在想一下怎麼改善</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        min_str = <span class="built_in">min</span>(strs, key=<span class="built_in">len</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">            <span class="comment"># 不判斷自己本身</span></span><br><span class="line">            <span class="keyword">if</span> strs[i] == min_str:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 設定 counter 變數，計算最小字串與當前字串的相同前綴長度</span></span><br><span class="line">                counter = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 比較當前字串與最小字串的每個字符</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(min_str)):</span><br><span class="line">                    <span class="keyword">if</span> strs[i][j] != min_str[j]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        counter += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 將當前字串的相同前綴長度存入結果</span></span><br><span class="line">                result[strs[i]] = min_str[:counter]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果 result 為空，代表 strs 中為空字串，則返回最小字串，否則則回傳 result 中最短前輟</span></span><br><span class="line">        <span class="keyword">return</span> min_str <span class="keyword">if</span> <span class="keyword">not</span> result <span class="keyword">else</span> <span class="built_in">min</span>(result.values(), key=<span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 2900: Longest Unequal Adjacent Groups Subsequence I</title>
      <link href="/2025/05/26/LeetCode-2900-Longest-Unequal-Adjacent-Groups-Subsequence-I/"/>
      <url>/2025/05/26/LeetCode-2900-Longest-Unequal-Adjacent-Groups-Subsequence-I/</url>
      
        <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><p>有一字串陣列 words 和 二元陣列 groups，兩個長度皆為 length n<br>words 的子序列是交錯的，當任何兩個連續的字串在序列中，且相對應的元素在 groups 是不同的索引時<br>則為子序列</p><p>題目的要求為從 words 找出最長交錯的子陣列<br>回傳 子陣列，如果有複數答案則回傳任何一個。</p><p>words 的每個元素是獨立的</p><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= n == words.length == groups.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>groups[i] is 0 or 1</code></li><li><code>words[i] is lowercase letter</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ol><li>建一個空陣列 result</li><li>把 words[0] 放進 result 陣列</li><li>遍訪 group 陣列，索引從 1 ~ range(len(groups))</li><li>當 groups[i] !&#x3D; groups[i - 1]，就放進去 result 陣列</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLongestSubsequence</span>(<span class="params">self, words, groups</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type groups: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        result = [words[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(groups)):</span><br><span class="line">            <span class="keyword">if</span> groups[i] != groups[i - <span class="number">1</span>]:</span><br><span class="line">                result.append(words[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 2942: Find Words Containing Character</title>
      <link href="/2025/05/26/LeetCode-2942-Find-Words-Containing-Character/"/>
      <url>/2025/05/26/LeetCode-2942-Find-Words-Containing-Character/</url>
      
        <content type="html"><![CDATA[<h2 id="題目："><a href="#題目：" class="headerlink" title="題目："></a>題目：</h2><p>給予一字串陣列 “words” 和一個字元 x<br>回傳符合的所有索引(以陣列表示) -&gt; 索引為 word 裡含有 ‘x’ 的字元的 key<br>(回傳的陣列有可能不照順序)</p><h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul><li><code>1 &lt;= words.length &lt;= 50</code></li><li><code>1 &lt;= words[i].length &lt;= 50</code></li><li><code>x is lowercase</code></li><li><code>words[i] 只包含 lowercase letter</code></li></ul><h2 id="解題思路："><a href="#解題思路：" class="headerlink" title="解題思路："></a>解題思路：</h2><ul><li>準備一個空陣列，從 words 字串陣列遍訪，如果有符合 <code>x</code> 字元，就將目前陣列的 <code>索引</code>  值放入空陣列</li><li>Python 可以直接用 <code>list comprehension</code> 生成陣列，條件判斷用 <code>[i for key, value in enumerate(words) if x in value]</code></li><li><code>enumerate</code> 對可迭代的物件進行遍訪，使用 <code>enumerate</code> 函數可以同時取得 <code>key</code> 和 <code>value</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findWordsContaining</span>(<span class="params">self, words, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type x: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># check words length is between 1 and 50</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(words) &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(words) &gt; <span class="number">50</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="comment"># check each word length is between 1 and 100</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(word) &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(word) &gt; <span class="number">50</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> word.islower() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="comment"># check x is lowercase letter</span></span><br><span class="line">        <span class="keyword">if</span> x.islower():</span><br><span class="line">            <span class="keyword">return</span> [i <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words) <span class="keyword">if</span> x <span class="keyword">in</span> word]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 基本設定</title>
      <link href="/2025/05/26/hexo-%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A/"/>
      <url>/2025/05/26/hexo-%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-基本設定"><a href="#Hexo-基本設定" class="headerlink" title="Hexo 基本設定"></a>Hexo 基本設定</h1><h2 id="初始化專案"><a href="#初始化專案" class="headerlink" title="初始化專案"></a>初始化專案</h2><pre><code>hexo init [folder name]</code></pre><p>範例</p><pre><code>hexo init my-blog</code></pre><h2 id="建立新文章"><a href="#建立新文章" class="headerlink" title="建立新文章"></a>建立新文章</h2><pre><code>hexo new [layout] &lt;標題&gt;</code></pre><p>範例</p><pre><code>hexo new post &quot;第一篇文章&quot;</code></pre><h2 id="local-端啟動伺服器"><a href="#local-端啟動伺服器" class="headerlink" title="local 端啟動伺服器"></a>local 端啟動伺服器</h2><pre><code>hexo server # 預設為 http://localhost:4000/</code></pre><h2 id="調整文章內容"><a href="#調整文章內容" class="headerlink" title="調整文章內容"></a>調整文章內容</h2><p>當執行完以下指令後:</p><pre><code>hexo new post &quot;第一篇文章&quot;</code></pre><p>會在 <code>source/_posts/</code> 底下產生 .md 檔案，<code>source/_posts/第一篇文章.md</code><br>.md 檔案內容如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---  </span><br><span class="line">title: 我的第一篇文章 By Hexo  </span><br><span class="line">date: 2021-03-07 17:15:57  </span><br><span class="line"><span class="section">tags:  </span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 文章標題</span></span><br><span class="line">內容自訂</span><br></pre></td></tr></table></figure><p>上面 <code>---</code> 包住的區域為 front-matter，用來敘述文章屬性，詳細參考 <a href="https://hexo.io/zh-tw/docs/front-matter">front-matter</a></p>]]></content>
      
      
      <categories>
          
          <category> 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
